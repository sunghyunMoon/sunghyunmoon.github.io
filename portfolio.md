---
title: Portfolio
feature_text: |
  배움이 즐거운 개발자, 문성현입니다.
feature_image: "https://picsum.photos/2560/600?image=873"
excerpt: "A demo of Markdown and HTML includes"
aside: true
---

## I'm...
* Name : Sunghyun Moon
* Tel : 010 - 4900 - 5883
* Email : shmoonlight@kaist.ac.kr
* M.S. 2019 KAIST Electrical Engineering 
* Github : [https://github.com/sunghyunMoon](https://github.com/sunghyunMoon "https://github.com/sunghyunMoon")


## Award & Paper
* 문성현, Tianwai Bo, 김병곤, 김훈, “EML을 이용하여 생성된 40 Gb/s OFDM 신호의 Kramers-Kronig 직접 검출”, in Proc. COOC, 2018, paper W1-A. (우수 논문상)
* Sunghyun Moon, Tianwai Bo, Byung Gon Kim, Daeho Kim, and Hoon Kim, “Kramers-Kronig Direct Detection of 40-Gb/s OFDM Signal Generated by using EML” in Proc. OECC, 2018, paper 4B4-2.

## Work Experience
* Web Developer(2021.08 - current)
  * 협업 및 공동 편집이 가능한 협업툴 Super Word 개발(Office365, GoogleDocs와 같은 웹 오피스)
    * File이 아닌 문서 데이터를 요소별로 DB화 하여 데이터 기반의 생산성 플랫폼 개발
  * Full Stack
    * C++, TypeScript, React, Java, MySQL, Jest Unit Test
  * Super Word Graphic 개체 z-index Architecture 설계 및 구현
  * Super Word Memo UX 기획, Architecture 설계 및 구현
    * 직장 협업이 진화하고 있음에 따라 협업 툴로써 웹 친화적인 메모 기능 개발
    * 문서 편집 시 paragraph의 위치가 바뀌면 Reactive하게 위치가 바뀌는 메모 레이아웃 구현
* C++ Developer(2019.09 - 2021.08)
  * ToOffice Word 제품 개발
  * Static Analysis
  * XML Digital Signature Architecture 설계 및 구현
    * docx 문서의 인증과 무결성을 위한 PKI(Public Key Infrastructure) 기반 디지털 서명 기능
  * 탐색창 페이지 탭 refacotring 설계 및 구현
    * 1000 페이지 이상의 대용량 문서에서 탐색창 페이지 탭에 대해 Event-Driven Architectuire를 이용해 레이아웃

<hr class="MuiDivider-root MuiDivider-fullWidth css-3udx1k">

<h4 style="color:#008000">Blink Layout 분석을 통한 SuperWord Layout 성능 점검</h4>
* 개발 기간 : 2022.09 ~ 2022.10
* Blink Layout
  * DOM 요소의 크기와 위치를 결정하는 fragment를 만드는 과정
  * LayoutObject가 LayoutAlgorithm을 통해 결과물인 LayoutResult를 만들어 내는 과정

<div><img src= "/assets/img/post/layout_algorithm.PNG"></div>

* ConstraintSpace
  * **부모로부터 받은 Layout 정보**
  * offset : 어디서부터 레이아웃 할지에 대한 정보
  * available_space : 레이아웃 가능한 공간
  * exclusion_space : 레이아웃 불가능한 공간
* LayoutResult
  * **Fragment를 보관**
    * 일반적으로 LayoutObject와 1대1 관계
    * Page나 Column의 경우 1대다 일 수 있음
  * Fragmentation Context
    * **Fragmentation Type**으로 page, colum이 있고, 일반적인 경우는 none으로 설정됨
* Blink Dirty Layout System
  * LayoutObject는 **layout을 다시 할지 결정하는 dirty_bit**을 들고 있음
  * 텍스트가 입력된 layoutObject에 대해서 dirty_bit이 true로 설정
  * 부모 layoutObject마다 dirty_bit을 true로 설정
  * LayoutView까지 dirty_bit을 true로 설정한 후, LayoutView에 대해 레이아웃 수행

<div><img src= "/assets/img/post/dirty_layout.PNG"></div>

* Blink에서는 레이아웃 후 **모든 레이아웃을 다시 수행하지 않도록 layoutObject는 layoutResult를 캐싱**
* layoutResult에는 대표적으로 fragment와 offset 정보가 있어서 **경우에 따라서 캐싱해둔 layout_result를 재사용**
* Layout시 최상단 layoutObject는 항상 dirty_bit이 true기 때문에 layoutAlgorithm을 통해 fragment를 다시 만듬
* Layout 과정 속에서 자식의 **dirty_bit이 true이면 자식도 새롭게 fragment를 만들고**, 반대로 **dirty_bit이 clear한 경우는 캐싱 해둔 layoutResult를 통해서 재사용 여부를 결정**

* **Fragment Caching**
  * 엔터를 치면 밀려나는 paragraph들의 레이아웃
    * 밀려나는 paragraph 들은 dirty_bit이 clear하기 때문에 캐싱해둔 layoutResult를 통해 fragment 재사용 여부 결정
    * 캐싱해둔 layoutResult에 저장된 available_space와 offset을 새로운 값들과 비교
      * 모두 같은 경우, 캐싱 해둔 layout_result 재사용
      * offset만 밀리는 경우, layoutResult의 offset 정보만 업데이트 시키고, fragment 재사용

* 이와 같이 일반적인 BlinkLayout System 분석을 토대로한 SuperWord Layout 성능을 분석함


<hr class="MuiDivider-root MuiDivider-fullWidth css-3udx1k">

<h4 style="color:#008000">Super Word 메모 Architecture</h4>
* 개발 기간 : 2021.11 ~ 
* 기존 기록을 하기 위한 주석 관점의 메모에서 **의견을 주고 받기 위한 협업 관점의 새로운 Super Word Comment UX/UI 제안**
* 레퍼런스 웹 오피스 제품인 office365, google docs의 메모 기능(simple editor)을 뛰어 넘어 OOXML 스펙 기반의 paragraph, 그림, 테이블 등이 삽입 가능한 메모 기능(complex editor) 구현

<div><img src= "/assets/img/post/modern_comment.gif"></div>

* 기존의 말풍선을 클릭하면서 열었다 닫을 수 있는 다이얼로그의 형태에서 페이지의 오른쪽에서 언제든 볼 수 있는 코멘트 박스의 형태로  UI를 변경
* **Submit 기능**을 추가해 메모 내용을 작성하고 **Submit을 눌러야 해당 메모가 DB에 저장**되도록 변경

<div><img src= "/assets/img/post/legacy_comment.gif"></div>

* Comment DB
  * 내부에 메모 단위로 comment element가 존재하고, 메모 내용이 paragraph element들이 자식으로 달리는 형태
  * COMMENT_ELEMENT DB 테이블을 구성해 속성인 author, data, id를 관리

* Comment Layout
  * 본문의 레이아웃은 blink에서 처리하고, 코멘트 박스들에 대해서는 JS단에서 위치 업데이트
  * **본문의 렌더링이 모두 끝난 후에 후처리 방식으로 JS 단에서 위치 업데이트**
 
 <div><img src= "/assets/img/post/layout_comment.PNG"></div>

<hr class="MuiDivider-root MuiDivider-fullWidth css-3udx1k">

<h4 style="color:#008000">Super Word Graphic 개체 z-index Architecture</h4>
* 개발 기간 : 2021.09 ~ 2021. 11
* OOXML z-index
** 화면상에서 z 축 좌표를 의미
** OOXML 스펙상으로 z-index는 **unique한 id** & **양수**만 가능

<img src= "/assets/img/post/z_index_intro.PNG">

* MS 워드에서의 z-index
  * global하게 z-index 관리
  * Default(=251659264)부터 시작해 새로운 도형 생성 마다 문서 전체의 최대 z-index + 1024

<img src= "/assets/img/post/ms_word_zindex.PNG">

* 웹 표준 z-index
  * CSS의 z-index로 설정
  * 초깃값은 auto(=0)
  * 음수와 양수 모두 설정 가능 

<img src= "/assets/img/post/css_z_index.PNG">

* <span style="color:tomato; background-color:#fff5b1" >Stacking Context</span>
  * z-index가 설정되면 stacking context가 생성됨
  * Stacking context는 HTML element의 3차원으로 개념화
  * Stacking context에 따라 element의 부모/자식 간 페인트 순서가 결정됨
  * Element -> negative z-index children -> normal flow children 
       -> z-index==0 children  -> positive z-index children
  
  <img src= "/assets/img/post/stacking_context_example.PNG">
  
    * 부모인 paragraph의 z-index가 있으면, 자식인 shape2의 z-index가 음수더라도 절대로 부모 밑으로 paint 될 수 없다.(paragraph이 stacking context를 생성하기 때문)
    * 부모인 paragraph의 z-index가 없으면, stacking context가 생성되지 않기 때문에, 자식의 z-index가 음수이면 부모 밑으로 paint 된다.
* Super Word/Hangul z-index 설계
  * 웹 표준 z-index를 CSS style에 설정해 구현
  * 이전 ToOffice에서는 Paint단에서 layer를 제어했지만, SuperOffice에서는 웹 표준 z-index를 사용



<hr class="MuiDivider-root MuiDivider-fullWidth css-3udx1k">

<h4 style="color:#008000">탐색창 페이지 탭 Lazy Synchronization Architecture</h4>
* 개발 기간 : 2020.10 ~ 2020. 12
* 탐색창 페이지 탭?
  * 검색 기능을 제공하는 툴페인으로 **페이지탭**이라는 세부 기능이 존재
  * 페이지탭 기능은 **문서 전체 페이지를 미리보기 리스트 형태**로 보여주며 본문의 셀렉션에 따라 현재 보고있는 페이지에도 강조표시가 됨
  * 페이지탭의 페이지 이미지를 클릭하면 해당 페이지로 본문이 이동 됨
  * 검색 기능도 제공하는데 검색한 단어가 있는 페이지만 모아서 보여주기도 함
<img src= "/assets/img/post/search_toolpane_intro.PNG">
* 문제 상황
  * 예를 들어, 총 1000페이지 문서에서 탐색창은 1000페이지를 보고 있고, 사용자는 1페이지에서 enter를 칠 경우
<img src= "/assets/img/post/search_toolpane_issue.PNG">
* 탐색창이 닫힌 경우, 1페이지에서 enter를 쳐도 editing이 연속적으로 가능
* 탐색창이 열려 1000페이지를 보고 있고, 사용자는 1페이지에서 editing 할 경우
  * 한번에 1000페이지까지 레이아웃 후 탐색창에 업데이트, 그 과정 동안 <span style="color:tomato; background-color:#fff5b1" > 사용자 editing이 block되는 문제</span>
* **레퍼런스 제품인 MS의 경우도 본문과 탐색창의 sync를 맞춘 후** editing이 가능하기 때문에 editing block 현상이 있었음
  * Word는 첫 페이지에서 엔터를 치면 그 아래 paragrpah 들의 위치가 밀려나게 되고 페이지도 늘어날 수 있게 된다. 그래서 엔터 친 아래의 모든 paragraph들의 좌표를 정해주는 layout이라는 과정을 거쳐야 한다. layout은 이전 paragraph의 위치와 높이가 정해져 있어야 다음 paragraph을 layout할 수가 있기 때문에, layout은 항상 위에서부터 아래로 진행이 된다.
  * 1000 페이지 정도의 문서를 한번에 layout하는 것은 소모가 큰 작업이고, **1000페이지를 layout한 결과를 바탕으로 페이지 탭을 rendering해주기 때문에, editin block 현상이 생김**
* 본문과 탐색창의 sync보다는 사용자 editing이 우선이라고 판단함
  * <span style="color:tomato; background-color:#fff5b1" >사용자의 editing이 가능하면서 sync를 맞추는 방법이 없을까?</span>
  * 아이디어 : 본문과 탐색창을 lazy하게 sync를 맞추어 사용자 editing을 가능하게 하자
* 본문의 viewport 이후의 페이지에 대해서는 Event-Driven Architecture를 이용해 본문과 탐색창을 lazy하게 sync를 맞추어 사용자 editing이 가능하도록 해결함
* Event-Driven?
  * IT 영역에서 아주 오래된 키워드
  * 어떤 하나의 큰 일을 잘게 쪼갠것들을 각각 **task**라고 지정한 다음 UI event를 계속 받아야 하는 event loop에 순서대로 넣어주는 것으로 생각하면 이해가 쉬울듯 하다. 이렇게 하면 task 사이 사이 사용자의 event가 들어올 수 있어, 사용자가 editing을 하면서도 페이지 Layout이 가능하게 된다. 

<hr class="MuiDivider-root MuiDivider-fullWidth css-3udx1k">

<h4 style="color:#008000">XML Digital Signature Architecture 설계 및 구현</h4>
* 개발 기간 : 2020.02 ~ 2020. 07
* 디지털 서명?
  * 문서를 작성한 서명자가 내가 예상한 서명자 인지를 보장할 수 있음
  * 디지털 서명된 문서는 전송 과정 중 어떠한 위변조도 없는 것을 보장할 수 있음
  
<img src= "/assets/img/post/digital_signature.PNG">
* 분석
  * HTTPS 통신에 사용되는 SSL 인증서에 대한 이해 및 인증서 관리 분석
    * OS에 기본으로 내장된 웹 브라우저에서 CA의 공개키가 들어 있는 인증서들을 어떻게 관리하고, 내장된 CA의 인증서를 이용해 서버로 받은 인증서를 검증할 때 어떤 라이브러리들을 사용하는지에 대해 분석함
  * PKI(Public Key InfraStrurcture) 기술 이해
    * 공개키를 인증하기 위한 공개키 인증서, 전자서명의 서명과 인증 원리, CA, 인증서 체인, X.509 포맷 등 PKI의 구조에 대한 연구
  * XML 전자 서명 연구
    * docx 워드 파일은 다양한 xml 파일들로 packaging 되어 있는 형태이고, 전자서명을 하면 docx 안에 xmlsignatures라는 디렉토리에 sig.xml이라는 xml 파일이 생성됨
    * sig.xml 파일 안에 있는 모든 XML element와 attribute를 W3C에서 재정한 XML Signautre Syntax and Processing Version 1.1와 XML Advanced Electronic Signatures (XAdES) 표준 문서를 보며 연구
* 계층적 해싱 구조
  * W3C에서 재정한 XML Signautre Syntax and Processing Version 1.1 문서를 참고해 XML 전자서명 연구를 시작하면서, MS 오피스의 XML 전자서명 스펙은 일반적인 XML 전자서명 스펙과 조금 다른 형식이라는 것을 알게됨
  * 일반적인 XML 전자서명이 XML 문서 하나 혹은 메시지 하나를 암호화하는 것에 비해, MS 오피스 XML 전자서명은 다양한 xml 파일들로 구성된 docx 파일의 위변조를 검증해야 하기 때문에 계층적 해싱 구조를 가짐
  * 계층적 해싱 구조는 모든 개별 데이터 각각을 해싱한 다음 해쉬값을 모아서 다시 해싱하는 방식을 의미함
  * 계층적 해싱 구조를 가진 XML 전자서명을 연구하면서 단순히 하나의 메시지 혹은 데이터가 아닌, packaing 형태의 압축파일 혹은 블록 단위에 대해서 전자서명하고 위변조를 검증하는 방법을 배움

  <hr class="MuiDivider-root MuiDivider-fullWidth css-3udx1k">