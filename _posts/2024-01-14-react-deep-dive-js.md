---
title: 1장 리액트 개발을 위해 꼭 알아야 할 자바스크립트
categories:
- React Deep Dive
feature_image: "https://cdn.geekboots.com/geek/javascript-hero-1652702096795.webp"
---

2024년 새해, 새로운 마음 가짐으로 모던 리액트 Deep Dive 책을 정독하기로 해본다. 프런트엔드 분야는 다른 기술 분야에 비해 진입장벽이 상대적으로 낮고 웹서비스를 손쉽고 빠르게 만들 수 있다는 장점 덕분에 많은 사람들, 특히 비전공자들이 진입하는 경우가 많다. 하지만, 리액트와 자바스크립트 사이에 겉으로 드러나지 않는 사실 을 완벽하게 이해하는 과정에 도전하게 된다면 다른 기술 분야와 마찬가지로 프런트엔드 역시 절대 쉽지 않다는 것을 깨닫게 된다. 이 책을 통해 리액트에 대해서 다시 살펴보며 생각을 정리해본다.

1장에서는 리액트 코드의 기반이 되는 자바스크립트에 대해 먼저 알아본다. 그러나 단순히 리액트 코드를 작성하는 데 그치지 않고, 웹 애플리케이션이 작동하는 이면에서 리액트가 수행하는 작업을 이해하려면 자바스크립트의 개념을 다시금 짚어볼 필요가 있다.

#### 1.1 자바스크립트의 동등 비교

- 리액트 함수형 컴포넌트와 훅을 반복적으로 작성하다 보면 의존성 배열(dependencies)에 대해 고민해 본 적이 있을 것이다. 실제로 이것이 어떤 식으로 작동하는지, 또한 왜 이러한 변수들을 넣어야 하는지 이해하지 못하는 경우가 많다.
- 또 렌더링 관점에서도 살펴볼 만한 이유가 있다. 리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나가 바로 props의 동등 비교에 따른 결과다. 그리고 이 props의 동등 비교는 객체의 얕은 비교를 기반으로 이뤄지는데, 이 얕은 비교가 리액트에서 어떻게 작동하는지 이해하지 못하면 렌더링 최적화에 어려움을 겪을 가능성이 크다.
- 리액트의 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다. 자바스크립트의 이러한 동등 비교는 어떻게 수행되는지, 또 이를 리액트에서 어떻게 활용하고 있는지 살펴보자.

##### 1.1.1 자바스크립트의 데이터 타입

- 자바스크립트의 모든 값은 데이터 타입을 갖고 있으며, 이 데이터 타입은 크게 원시 타입과 객체 타입으로 나눌수 있다.
    - 원시 타입
        - boolean, null, undefined, number, string, symbol, bigint
    - 객체 타입
        - object

<h5>객체 타입</h5>

- 객체 타입을 간단하게 정의하면 앞서 7가지 원시 타입 이외의 모든 것, 즉 자바스크립트를 이루고 있는 대부분의 타입이 바로 객체 타입이다.
- 여기서 한 가지 주목할 것이 객체 타입(object type)은 참조를 전달한다고 해서 참조 타입(reference type)으로도 불린다는 사실이다.

```js
typeof [] ==== 'object' // true
typeof {} === 'object' // true
function heUo() {}
typeof hello === 'function' // true
const hellol = function () {}
const hello2 = function () {}
// 객체인 함수의 내용이 육안으로는 같아 보여도 참조가 다르기 때문에 false가 반환된다.
hellol === hello2 // false
```

##### 1.1.2 값을 저장하는 방식의 차이

- **원시 타입과 객체 타입의 가장 큰 차이점이라고 한다면, 바로 값을 저장하는 방식의 차이**다. 이 값을 저장하는 방식의 차이가 동등 비교를 할 때 차이를 만드는 원인이 된다.
- 먼저 **원시 타입은 불변 형태의 값으로 저장**된다. 그리고 이 값은 변수 할당 시점에 메모리 영역을 차지하고 저장된다.

```js
let hello = 'hello world'
let hi = hello
console.log(hello === hi) // true
```

- 는 hello의 hello world라는 값이 hi에 복사해 전달됐기 때문이다. 값을 비교하기 때문에, 값을 전달하는 방식이 아닌 각각 선언하는 방식으로도 동일한 결과를 볼수 있다.

```js
let hello = 'hello world'
let hi = 'hello world'
console. log(hello === hi) // true
```

- 반면 **객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 원시 값과 다르게 변경 가능한 형태로 저장되며, 값을 복사할 때도 값이 아닌 참조를 전달**하게 된다.

```js
// 다음 객체는 완벽하게 동일한 내용을 가지고 있다.
var hello = {
    greet: 'hello, world',
}
var hi = {
    greet： 'hello, world',
}
// 그러나 동등 비교를 하면 false가 나온다.
console.log(hello === hi) // false
// 원시값인 내부 속성값을 비교하면 동일하다.
console.log(hello.greet === hi.greet) // true
```

- 따라서 자바스크립트 개발자는 항상 객체 간에 비교가 발생하면, 이 객체 간의 비교는 우리가 이해하는 내부의 값이 같다 하더라도 결과는 대부분 true가 아닐 수 있다는 것을 인지해야 한다.

##### 1.1.3 자바스크립트의 또 다른 비교공식, Object.is

- 자바스크립트에서는 비교를 위한 또 한 가지 방법을 제공하는데, 바로 Object.is다. Object.is는 두 개의 인수를 받으며, 이 인수 두 개가 동일한지 확인하고 반환하는 메서드다. Object.is가 ==나 ===와 다른 점은 다음과 같다.

- == vs. Object.is: == 비교는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환 (type casting)을 한 후에 변경한다. 따라서 5 == ' 5'와 같이 형변환 후에 값이 동일하다면 ==는 true를 반환한다. 하지만 Object.is는 이러한작업을하지 않는다. 즉. === 와동일하게 타입이 다르면 그냥 false다.
- === VS. Object.is： 이 방법에도 차이가 있다. 다음코드를 보면 알수 있듯, Object.is가좀 더 개발자가 기대하는 방식으로 정확히 비교한다.
- . 한 가지 주의해야 할 점은, Object.is를 사용한다 하더라도 객체 비교에는 별 차이가 없다는 것이다. 객체 비교는 앞서 이야기한 객체 비교 원리와 동등하다.

##### 1.1.4 리액트에서의 동등 비교

- 그렇다면 리액트에서는 동등 비교가 어떻게 이루어질까? 리액트에서 사용하는 동등 비교는 ==나 ===가 아닌 이 Object.is다. Object.is는 ES6에서 제공하는 기능이기 때문에 리액트에서는 이를 구현한 폴리필(Polyfill)을 함께 사용한다.
- 리액트에서의 비교를 요약하자면 **Object.is로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교, 즉 객체 간 얕은 비교**를 한 번 더 수행하는 것을 알 수 있다. 객체 간 얕은 비교란 객체의 첫 번째 깊이에 존재하는 값만 비교한다는 것을 의미한다.

```js
// Object.is는 참조가 다른 객체에 대해 비교가 불가능하다.
Object.is({ hello: 'world' }, { hello： 'world' }) // false
// 반면 리액트 팀에서 구현한 와allowEq니al은 객체의 1 depth까지는 비교가 가능하다.
shallowEqual({ hello: 'world' }, { hello： 'world' }) // true
// 그러나 2 depth까지 가면 이를 비교할 방법이 없으므로 false률 반환한다.
shallowEqual({ hello： { hi: 'world' } }, { hello: { hi: 'world' } }) // false
```

- 이렇게 객체의 얕은 비교까지만 구현한 이유는 무엇일까? 먼저 **리액트에서 사용하는JSX props는 객체이고, 그리고 여기에 있는 props만 일차적으로 비교하면 되기 때문**이다.
- 기본적으로 리액트는 props에서 꺼내온 값을 기준으로 렌더링을 수행하기 때문에 일반적인 케이스에서는 얕은 비교로 충분할 것이다. 이러한 특성을 안다면 props에 또 다른 객체를 넘겨준다면 리액트 렌더링이 예상치 못하게 작동한다는 것을 알수 있다.

##### 1.1.5 정리

- 지금까지 자바스크립트에 존재하는 데이터 타입은 무엇인지, 그리고 이 데이터 타입은 어떻게 저장되며 이값의 비교는 어떻게 수행되는지 살펴봤다.
- 자바스크립트를 기반으로 한 리액트의 함수형 프로그래밍 모델에서도 언어적인 한계를 뛰어넘을 수 없으므로 **얕은 비교만을 사용해 비교를 수행해 필요한 기능을 구현**하고 있다.
- 이러한 자바스크립트의 특징을 잘 숙지한다면 향후 함수형 컴포넌트에서 사용되는 훅의 의존성 배열의 비교, 렌더링 방지를 넘어선 useMemo와 useCallback의 필요성, 렌더링 최적화를 위해서 꼭 필요한 React.memo를 올바르게 작동시키기 위해 고려해야 할 것들을 쉽게 이해할 수 있을 것이다.

#### 1.2 함수

##### 1.2.1 함수란 무엇인가?

- 자바스크립트에서 함수란 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것을 의미한다.
- 리액트에서 컴포넌트를 만드는 함수도 이러한 기초적인 형태를 따르는 것을 알 수 있다.

```js
function Component(props) {
    return <div>{props.hello}</div>
}
```

- Component라고 하는 함수를 선언하고 매개변수로는 일반적으로 props라고 부르는 단일 객체를 받으며 return 문으로 JSX를 반환한다.

##### 1.2.2 함수를 정의하는 4가지 방법

- 자바스크립트에서 함수를 정의하는 방법은 크게 4가지로 나눌 수 있다.

<h5>함수 선언문</h5>

- 자바스크립트에서 함수를 선언할 때 가장 일반적으로 사용하는 방식이다.

```js
f니nction add(a, b) {
    return a + b
}
```

- 함수 선언문은 표현식이 아닌 일반 문(statement)으로 분류된다. 표현식이란 무언가 값을 산출하는 구문을 의미한다. 즉, 앞선 함수 선언으로는 어떠한 값도 표현되지 않았으므로 표현식이 아닌 문으로 분류된다.

```js
const sum = function suiii(a_, b) {
    return a + b
}
sum(10, 24) // 34
```

- 위 예제는 마치 sum이라는 변수에 함수 sum을 할당하는, 표현식과 같은 작동을 보였다. 그 이유는 무엇일까? 
-  자바스크립트 엔진이 코드의 문맥에 따라 동일한 함수를 문이 아닌 표현식으로 해석하는 경우가 있기 때문이다.

<h5>함수 표현식</h5>

- 함수 표현식에 대해 알아보기 전에 ‘일급 객체’라는 개념을 알고 있어야 한다. 프로그래밍 세계에서 일급객체란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 의미한다.
-  자바스크립트에
서 함수는 일급 객체다. 함수는 다른 함수의 매개변수가 될 수도 있고, 반환값이 될 수도 있으며, 앞에서 본 것처럼 할당도 가능하므로 일급 객체가 되기 위한 조건을 모두 갖추고 있다.

<h5>함수 표현식과 선언 식의 차이</h5>

- 이 두 가지 방식의 가장큰 차이는 호이스팅(hoisting) 여부다. 함수의 호이스팅이라 함은, 함수 선언문이 마치 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징을 의미한다.

```js
hello() // hello
function hello() {
    console.log('hello')
}
hello() // hello
```

- 함수의 호이스팅은 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업을 의미한다. 이러한 함수의 호이스팅이라는 특징 덕분에 함수 선언문이 미리 메모리에 등록됐고, 코드의 순서에 상관없이 정상적으로 함수를 호출할 수 있게 된 것이다.

- 반면 함수 표현식은 함수를 변수에 할당했다. 변수도 마찬가지로 호이스팅이 발생한다. 그러나 함수의 호이스팅과는 다르게, 호이스팅되는 시점에서 var의 경우에는 undefined로 초기화한다는 차이가 있다. 
- **함수와 다르게 변수는, 런타임 이전에 undefined로 초기화되고, 할당문이 실행되는 시점, 즉 런타임 시점에 함수가 할당되어 작동한다는 것**을 알 수 있다.

<h5>Function 생성자</h5>

```js
const add = new Fiinction('a', 'b', 'return a + b')
add(10, 24) // 34
```

- Function 생성자 함수를 사용해서 만든 모습은 썩 좋아보이지 않는다. 코드 작성 관점에서만 보더라도 매개변수, 그리고 함수의 몸통을 모두 문자열로 작성해야 한다.

<h5>화살표 함수</h5>


```js
const add = (a, b) => {
    return a + b
}
const add = (a, b) => a + b
```
-  화살표 함수는 겉보기와 다르게 앞서 언급한 함수 생성 방식과 몇 가지 큰 차이점이 있다.
- 먼저 화살표 함수에서는 constructor를 사용할 수 없다.
- 그리고 화살표 함수에서는 arguments가 존재하지 않는다.
- 그리고 화살표 함수와 일반 함수의 가장 큰 차이점은 바로 this 바인딩이다.
- 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 따르게 된다

#### 1.4 클로저

- 리액트의 클래스형 컴포넌트에 대한 이해가 자바스크립트의 클래스, 프로토타입 , this에 달려 있다면, 함수형 컴포넌트에 대한 이해는 클로저에 달려 있다.
- 함수형 컴포넌트의 구조와 작동 방식, 훅의 원리, 의존성 배열 등 함수형 컴포넌트의 대부분의 기술이 모두 클로저에 의존하고 있기 때문에 함수형 컴포넌트 작성을 위해서는 클로저에 대해 이해하는 것이 필수다.

##### 1.4.1 클로저의 정의

- 먼저 클로저에 대한 정의를 MDN에서 찾아보면 “클로저는 함수와 함수가 선언된 어휘적 환경(Lexical Scope)의 조합이라고 돼 있다.
-  그러나 리액트에서 함수형 컴포넌트와 훅이 등장한 16.8 버전을 기점으로 이 클로저라는 개념이 리액트에서 적극적으로 사용되기 시작하면서 클로저를 빼놓고서는 리액트가 어떤 식으로 작동하는지 이해하기 어려워졌다. 클로저는 무엇이고, 어떻게 활용되는지 살펴보자.
- **“선언된 어휘적 환경”이라는 것은, 변수가 코드 내부에서 어디서 선언됐는지를 말하는 것**이다. 이는 앞서 이야기한, 호출되는 방식에 따라 동적으로 결정되는 this와는 다르게 코드가 작성된 순간에 정적으로 결정된다. 클로저는 이러한 어휘적 환경을 조합해 코딩하는 기법이다.

##### 1.4.3 클로저의 활용

- 전역 스코프는 어디서든 원하는 값을 꺼내올 수 있다는 장점이 있지만, 반대로 이야기하면 누구든 접근할 수 있고 수정할 수 있다는 뜻도 된다. 다음 예제를 살펴보자.

```js
var counter = 0
function handleClickO {
    coiinter++
}
```

- 위 counter 변수는 큰 문제를 가지고 있다. 첫째, 전역 레벨에 선언돼 있어서 누구나 수정할 수 있다. 앞서 예제로 확인했던 것처럼 window.counter를 활용하면 쉽게 해당 변수에 접근할 수 있을 것이다.
- **만약 리액트의 usestate의 변수가 전역 레벨에 저장돼 있으면 어떻게 될까?** 자바스크립트를 조금만 아는 사람이라면 누구나 리액트 애플리케이션을 쉽게 망가뜨릴 것이다.
- 리액트가 관리하는 내부 상태 값은 리액트가 별도로 관리하는 클로저 내부에서만 접근할 수 있다.
- 클로저를 활용하면 전역 스코프의 사용을 막고, 개발자가 원하는 정보만 개발자가 원하는 방향으로 노출시킬 수 있다는 장점이 있다.

<h5>리액트에서의 클로저</h5>

- 그렇다면 리액트 함수형 컴포넌트의 훅에서 클로저는 어떻게 사용될까? 클로저의 원리를 사용하고 있는 대표적 인 것 중 하나가 바로 useState다.

```js
function ComponentO {
const [state, setState] = useState()
function handleClickO {
    // usestate 호출윤 위에서 끝났지만,
    // setstate는 계속 내부의 최신값(prev)을 알고 있다.
    // 이는 클로저를 활용했기 때문에 가능하다.
    setState((prev) => prev + 1)
}
// ...
```

- useState 함수의 호출은 Component 내부 첫 줄에서 종료됐는데, setState는 useState 내부의 최신 값을 어떻게 계속해서 확인할 수 있을까? 그것은 바로 **클로저가 usestate 내부에서 활용됐기 때문**이다.
- **외부 함수(useState)가 반환한 내부 함수(setState)는 외부 함수(useState)의 호출이 끝났음에도 자신이 선언된 외부 함수가 선언된 환경(state가 저장돼 있는 어딘가)을 기억하기 때문에 계속해서 state 값을 사용할 수 있는 것**이다.

##### 1.4.4 주의할 점

- 

<h3>끝!</h3>
