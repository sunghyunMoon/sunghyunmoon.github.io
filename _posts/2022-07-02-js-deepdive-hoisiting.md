---
title: 호이스팅
categories:
- Modern JavaScript DeepDive
feature_image: "https://cdn.geekboots.com/geek/javascript-hero-1652702096795.webp"
---

오늘은 호이스팅이라는 개념에 대해 정리해 보고자 한다. Modern JavaScript DeepDive에서 서술한 호이스팅에 관한 모든 것을 정리해봤다.

#### 4.4 변수 선언의 실행 시점과 변수 호이스팅

- 다음 예제를 살펴보자.
```javascript
    console.log（score）; // undefined
    var score; // 변수 선언문
```

- 변수 선언문보다 변수를 참조하는 코드가 앞에 있다. 자바스크립트 코드는 인터프리터에 의해 한 줄씩 순차적으로 실행되므로 console.log(score）;가 가장 먼저 실행되고 순차적으로 다음 줄에 있는 코드를 실행한다. 따라서 console.log（score）;가 실행되는 시점에는 아직 score 변수의 선언이 실행되지 않았으므로 참조 에러(ReferenceError)가 발생할 것처럼 보인다.
- **하지만 참조 에러가 발생하지 않고 undefined가 출력**된다.
- 그 이유는 **변수 선언**이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 **런타임(runtime)이 아니라 그 이전 단계에서 먼저 실행되기 때문**이다.
- 자바스크립트 엔진은 소스코드를 한줄씩 순차적으로 실행하기에 앞서 먼저 **소스코드의 평가과정**을 거치면서 소스코드를 실행하기 위한 준비를 한다. 이때 소스코드 실행을 위한 준비 단계인 **소스코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문（변수 선언문, 함수 선언문 등）을 소스코드에서 찾아내 먼저 실행**한다.
- 그리고 소스코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.
- **즉, 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행**한다. 따라서 변수 선언이 소스코드의 어디에 위치하는지와상관없이 어디서든지 변수를 참조할 수 있다.
- 위 예제는 변수 선언（선언 단계와 초기화 단계）이 소스코드가 순차적으로 실행되는 런타임 이전 단계에서 먼저 실행된다는 증거다. 이처럼 **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(varible hoisting)**이라 한다.
- 사실 변수 선언뿐 아니라 var. let, const, function, function*, class 키워드를 사용해서 선언하는 모든식별자(변수, 함수, 클래스 등）는 호이스팅된다. 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문이다.

#### 12.4.3 함수 생성 시점과 함수 호이스팅

- 다음 예제를 살펴보자.

```js
    // 함수 참조
    console.dir(add); // / add(x, y)
    console.dir(sub); // undefined
    // 함수 호출
    console.log(add(2, 5)); // 7
    console.log( sub(2, 5)); // TypeError: sub is not a function

    function add(x, y) {
    return x + y;
    }
    // 함수 표현식
    var sub = function (x, y) {
    return x - y;
    };

```

- 위 예제와 같이 **함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다**. 그러나 **함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.** 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.
- 모든 선언문이 그렇듯 함수 선언문도 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다. 다시 말해. **함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성**된다. 그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.
- 즉, 코드가 한 줄씩 순차적으로 실행되기 시작하는 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태다. 따라서 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있다. 이처럼 **함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 함수 호이스팅(function hoisting)이라 한다.**

- **함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문**이다. 따라서 함수 표현식은 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작한다. **변수 선언은 런타임 이전에 실행**되어 undefined로 초기화되지만 **변수 할당문의 값은** 할당문이 실행되는 시점, 즉 **런타임에 평가**되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.
- 따라서 **함수 표현식으로 함수를 정의**하면 함수 호이스팅이 발생하는 것이 아니라 **변수 호이스팅이 발생**한다. 따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 한다.

<div><img src= "/assets/img/post/function_hoisiting.PNG"></div>

##### 함수 호이스팅과 변수 호이스팅의 미묘한 차이?

- var 키워드를 사용한 변수 선언문과 함수 선언문은 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동
일하다. 하지만 **var 키워드로 선언된 변수는 undefined로 초기화**되고, **함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화**된다.

#### 15.1.3 var 키워드의 변수 호이스팅

- **var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작**한다. 즉, 변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다.

#### 15.2.3 let 키워드의 변수 호이스팅

- var 키워드로 선언한 변수와 달리 **let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작**한다. 다음 예제를 살펴보자.

```js
   console.log(foo); // ReferenceError: foo is not defined
    let foo;
```

- 이처럼 let 키워드로 선언한 변수를 변수 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다.
- var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 “선언 단계”와 “초기화 단계”가 한번에 진행된다. 즉, 선언 단계에서 스코프(실행 컨텍스트의 렉시컬 환경Lexical Environment)에 변수 식별자를 등록해 자바스크립트 엔진에 변수의 존재를 알린다. 그리고 즉시 초기화 단계에서 undefined로 변수를 초기화한다.
- **let 키워드로 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행**된다. 즉, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 **초기화 단계는 변수 선언문에 도달했을 때 실행**된다.
- **let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지 변수를 참조할 수 없다.** 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간을 일시적 사각지대(Temporal DeadZone: TDZ)라고 부른다.
- 결국 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 보인다. 하지만 그렇지 않다. 다음 예제를 살펴보자.

```js
   let foo = 1; // 전역 변수
    {
    console.log(foo); // ReferenceError: Cannot access 'foo' before initialization
    let foo = 2; // 지역 변수
    }
```

- let 키워드로 선언한 변수의 경우 변수 호이스팅이 발생하지 않는다면 위 예제는 전역 변수 foo의 값을 출력해야 한다. **하지만 let 키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조 에러가 발생**한다.
- 자바스크립트는 **ES6에서 도입된 let, const를 포함해서 모든 선언(var, let, const, function, function* class 등)을 호이스팅한다.** **단, ES6에서 도입된 let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작**한다.

#### 25.3 클래스 호이스팅

- 클래스는 함수로 평가된다.

```js
   // 클래스 선언문
    class Person {}
    console.log(typeof Person); // function
```

- **클래스 선언문으로 정의한 클래스는** 함수 선언문과 같이 소스코드 평가 과정, 즉 **런타임 이전에 먼저 평가되어 함수 객체를 생성**한다. 이때 클래스가 평가되어 생성된 함수 객체는 생성자 함수로서 호출할 수 있는 함수, 즉 constructor다. 

- 클래스는 클래스 정의 이전에 참조할 수 없다.

```js
   console.log(Person);
    // ReferenceError: Cannot access 'Person’ before initialization
    // 클래스 선언문
    class Person {}
```

- 클래스 선언문은 마치 호이스팅이 발생하지 않는 것처럼 보이나 그렇지 않다. 다음 예제를 살펴보자.

```js
   const Person = '';
    {
    // 호이스팅이 발생하지 않는다면 ’ '이 출력되어야 한다.
    console.log(Person);
    // ReferenceError: Cannot access 'Person' before initialization
    // 클래스 선언문
    class Person {}
    }

```

- 클래스 선언문도 변수 선언, 함수 정의와 마찬가지로 호이스팅이 발생한다. 단, 클래스는 let, const 키워드로 선언한 변수처럼 호이스팅된다. 따라서 **클래스 선언문 이전에 일시적 사각지대에 빠지기 때문에 호이스팅이 발생하지 않는 것처럼 동작**한다.


<h3>끝!</h3>