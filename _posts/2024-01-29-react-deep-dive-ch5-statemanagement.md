---
title: 5장 리액트와 상태 관리 라이브러리
categories:
- React Deep Dive
feature_image: "https://raw.githubusercontent.com/sunghyunMoon/sunghyunmoon.github.io/main/assets/img/background/react.png"
---

이번 장에서는 리액트 애플리케이션을 개발할 때 빠지지 않고 언급되는 상태 관리 라이브러리에 대해 알아본다. 많은 개발자들이 리액트 애플리케이션에 자신이 익숙한 상태 관리 라이브러리를 설치하는 것을 익숙해하지만 정작 왜 상태 관리가 필요한지, 또 이 상태 관리가 어떻게 리액트와 함께 작동하는지는 간과하는 경우가 많다. 이번 장에서는 상태 관리 라이브러리의 필요성부터 최근 많이 주목받고 있는 상태 관리 라이브러리가 어떻게 작동하는지 살펴본다.

### 5.1 상태 관리는 왜 필요 한가?

-  상태 관리에 대해 이야기하기에 앞서 이제 앞으로 계속해서 이야기할 ‘상태’가 무엇인지 정의할 필요가 있다. 흔히 웹 애플리케이션을 개발할 때 이야기하는 상태는 어떠한 의미를 지닌 값이며 애플리케이션의 시나리오
에 따라 지속적으로 변경될 수 있는 값을 의미한다. 웹 애플리케이션에서 상태로 분류될 수 있는 것들은 대표적으로 다음과 같은 것이 있다.
    - **UI： 기본적으로 웹 애플리케이션에서 상태라 함은 상호 작용이 가능한 모든 요소의 현재 값을 의미**한다. 다크/라이트 모드, 라디오를 비롯한 각종 input, 알림창의 노출 여부 등 많은 종류의 상태가 존재한다.
    - URL： 브라우저에서 관리되고 있는 상태값으로, 여기에도 우리가 참고할 만한 상태가 존재할 수 있다. https://www.airbnb.co.kr7rooins/34：L13796?adults=2와 같은 주소가 있다고 가정해 보자. 이 주소에는 rooinld=34113796과 adults=2라고 하는 상태가 존재하며 이 상태는 사용자의 라우팅에 따라 변경된다.
    - 폼(form): 폼에도 상태가 존재한다. 로딩 중인지(loading), 현재 저g됐는지(submit). 접근이 불7|능한지(disabled), 값이 유효한지(validation) 등 모두가 상태로 관리된다.
    - 서버에서 가져온 값 클라이언트에서 서버로 요청을 통해 가져온 값도 상태로 볼 수 있다. 대표적으로 API 요청이 있다.

- 애플리케이션 전체적으로 관리해야 할 상태가 있다고 가정해 보자. 그리고 그 상태에 따라 다양한 요소들이 각 상태에 맞는 UI를 보여줘야 한다. 상태를 어디에 둘 것인가? 전역 변수에 둘 것인가? 별도의 클로저를 만들 것인가? 그렇다면 그 상태가 유효한 범위는 어떻게 제한할 수 있을까? 상태의 변화에 따라 변경돼야 하는 자식 요소들은 어떻게 이 상태의 변화를 감지할 것인가? 이러한 상태 변화가 일어남에 따라 즉각적으로 모든 요소들이 변경되어 애플리케이션이 찢어지는 현상(이를 tearing이라고 하며, 하나의 상태에 따라 서로 다른 결과물을 사용자에게 보여주는 현상을 말한다)을 어떻게 방지할 것인가?
- 이처럼 현대 웹 애플리케이션에서 상태 관리란 어렵다고 흐fl서 외면할 수 없는 주제가 됐다. 이러한 상태를 효율적으로 관리하고, 상태가 필요한 쪽에서는 빠르게 반응할 수 있는 모델에 대한 고민이 본격적으로 시작된 것이다.

#### 5.1.1 리액트 상태관리의역사

- 다른 웹 개발 환경과 마찬가지로 리액트도 상태 관리에 대한 필요성이 존재했다. 애플리케이션 개발에 모든 것을 제공하는, 이른바 프레임워크를 지향하는 Angular와는 다르게 **리액트는 단순히 사용자 인터페이스를 만들기 위한 라이브러리일 뿐이고, 그 이상의 기능을 제공하지 않고 있다..** 따라서 상태를 관리하는 방법도 개발자에 따라, 시간에 따라 많은 차이가 있다. 리액트 생태계에서 개발자들이 상태 관리를 하기 위해 어떠한 방법을 활용했는지 그 역사를 살펴보자.

<h5>Flux 패턴의 등장</h5>

- 리액트에서는 상태 관리, 특히 전역 상태 관리를 어떻게 했을까? 리덕스가 나타나기 전까지 리액트 애플리케이션에서 딱히 이름을 널리 알린 상태 관리 라이브러리는 없었다.
- 그러던 중 2014년경, 리액트의 등장과 비슷한 시기에 Flux 패턴과 함께 이를 기반으로 한 라이브러인 Flux를 소개하게 된다. Flux에 대해 소개하기에 앞서 먼저 이 당시 웹 개발상황을 짚고 넘어가자. **웹 애플리케이션이 비대해지고 상태（데이터）도 많아짐에 따라 어디서 어떤 일이 일어나서 이 상태가 변했는지 등을 추적하고 이해하기가 매우 어려운 상황이었다.**
- 페이스북 팀은 이러한 문제의 원인을 양방향 데이터 바인딩으로 봤다. **뷰（HTML）가 모델（자바스크립트）을 변경할 수 있으며, 반대의 경우 모델도 뷰를 변경할 수 있다. 이는 코드를 작성하는 입장에서는 간단할 수 있지만 코드의 양이 많아지고 변경 시나리오가 복잡해질수록 관리가 어려워진다.** 페이스북 팀은 양방향이 아닌 단방향으로 데이터 흐름을 변경하는 것을 제안하는데 이것이 바로 Flux 패턴의 시작이다.

<div><img src= "/assets/img/post/flux_flow.PNG"></div>

-  각 용어의 정의를 살펴보자.
    - 액션(action): 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터룰 의미한다. 액션 타입과 데이터를 각각 정의해 이를 디스패처로 보낸다.
    - 디스패처(dispatcher): 액션을 스토어에 보내는 역할을 한다. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.
    - 스토어(store): 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다. 액션의 타입에 따라 어떻게 이를 변경할지가 정의돼 있다.
    - 뷰(view)： 리액트의 컴포넌트에 해당하는 부분으로. 스토어에서 만들어진 데이터를 가져와 화면을 렌더링하는 역할을 한다. 또한 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트하고자 할 수 있을 것이다. 이 경우에는 다음 그림처럼 뷰에서 액션을 호출하는 구조로 구성된다.

<div><img src= "/assets/img/post/flux_flow2.PNG"></div>

- 간단하게 리액트 코드로 살펴보자.

```js
type storestate = {
count: number
}

type Action = { type: 'add'; payload: number }

function reducer(prevState: StoreState, action; Action) {
    const { type: ActionType } = action
    if (ActionType === 'add') {
        return {
            count: prevState.count + action.payload,
        }
    }
    throw new Error('Unexpected Action [${ActionType}]')
}

export default function App() {
    const [state, dispatcher] = useReducer(rediicer, { count： 0 })
    function handleClick() {
        dispatcher({ type: 'add', payload： 1 })
    }
    return (
        <div>
            <hl>{state.count}</hl>
            <button onClick={handleClick}>+</button>
        </div>
    )
}
```





<h3>끝!</h3>
